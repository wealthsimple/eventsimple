# frozen_string_literal: true

require 'active_model'
require 'active_support'
require 'dry-types'
require 'dry-struct'
require 'sidekiq'
require 'sidekiq-pro'

require 'dry_types'

require 'eventable/data_type'
require 'eventable/event_dispatcher'
require 'eventable/message'
require 'eventable/metadata_type'
require 'eventable/metadata'
require 'eventable/reactor_worker'

module Eventable # rubocop:disable Metrics/ModuleLength
  extend ActiveSupport::Concern

  class_methods do
    # rubocop:disable Metrics
    def event_driven_by(event_klass, aggregate_id: :canonical_id)
      has_many :events, class_name: event_klass.name.to_s,
        foreign_key: :aggregate_id,
        primary_key: aggregate_id,
        dependent: :delete_all,
        inverse_of: model_name.element.to_sym,
        autosave: false,
        validate: false

      class_attribute :ignored_for_projection, default: []

      class_eval do
        def projection_matches_events?
          reprojected = self.class.find(id).reproject

          attributes == reprojected.attributes
        end

        def reproject(at: nil)
          event_history = at ? events.where('created_at <= ?', at).load : events.load
          ignore_props = %w[id created_at updated_at lock_version].
            concat(ignored_for_projection).map(&:to_s)
          assign_attributes(self.class.column_defaults.except(*ignore_props))

          event_history.each do |event|
            event.apply(self)
          end

          self
        end
      end
    end
    # rubocop:enable Metrics

    # rubocop:disable Metrics
    def drives_events_for(model_klass, events_namespace: nil, aggregate_id: :canonical_id)
      class_eval do
        belongs_to model_klass.model_name.element.to_sym,
          foreign_key: :aggregate_id,
          primary_key: aggregate_id,
          class_name: model_klass.name.to_s,
          inverse_of: :events,
          autosave: false,
          validate: false

        around_save :with_database_role
        before_validation :extend_validation
        validate :_valid?
        before_create :apply_and_persist
        after_create :dispatch

        default_scope { order('created_at ASC') }

        self.inheritance_column = :type
        self.store_full_sti_class = false

        attribute :metadata, MetadataType.new
        attribute :skip_dispatcher, default: false
        attribute :skip_apply_check, default: false

        def with_database_role(&block)
          ApplicationRecord.connected_to(role: :writing, &block)
        end

        # Apply the event to the aggregate passed in. Must return the aggregate.
        # The default behaviour is a no-op
        def apply(aggregate)
          aggregate
        end

        def can_apply?(_aggregate)
          true
        end

        def _valid?
          return if skip_apply_check
          return if can_apply?(aggregate)

          errors.add(:base, :invalid_transition, message: 'Invalid Transition')
          aggregate.errors.add(:base, :invalid_transition, message: 'Invalid Transition')
        end

        def extend_validation
          validate_form = self.class.instance_variable_get(:@validate_with)
          self.aggregate = aggregate.extend(validate_form) if validate_form
        end

        # Apply the transformation to the aggregate and save it.
        define_method :apply_and_persist do
          # Apply!
          self.aggregate = apply(aggregate)

          # Persist!
          aggregate.save!

          # If the primary key is generated by the database, it might not be visible
          # until the aggregate has been persisted into the database.
          self.aggregate_id = aggregate.public_send(primary_key) if aggregate_id.nil?
        end

        def dispatch
          Dispatcher.dispatch(self) unless skip_dispatcher
        end

        define_method :aggregate do
          public_send(model_klass.model_name.element.to_s)
        end

        define_method :aggregate= do |aggregate|
          public_send("#{model_klass.model_name.element}=", aggregate)
        end
      end
      # rubocop:enable Metrics

      singleton_class.class_eval do
        define_method :validate_with do |form_klass|
          @validate_with = form_klass
        end

        # We don't store the full namespaced class name in the events table.
        # Events for an entity are expected to be namespaced under events_namespace.
        define_method :find_sti_class do |type_name|
          if events_namespace.blank?
            super(type_name)
          else
            super("#{events_namespace}::#{type_name}")
          end
        end

        # We want to automatically retry writes on concurrency failures. However events with sync
        # reactors may have multiple nested events that are writen within the same transaction.
        # We can only catch and retry writes when they the outermost event encapsulating the whole
        # transaction.
        def create(*args, &block)
          with_retries(args) { super }
        end

        def create!(*args, &block)
          with_retries(args) { super }
        end

        define_method :with_retries do |args, &block| # rubocop:disable Metrics/AbcSize
          entity = args[0][model_klass.model_name.element.to_sym]

          # Only implement retries when the event is not already inside a transaction.
          if entity && !ActiveRecord::Base.connection.transaction_open?
            Retriable.retriable(
              on: ActiveRecord::StaleObjectError,
              intervals: [0, 0],
              on_retry: proc {
                Rails.logger.info("Retrying event #{name} #{model_klass.model_name.element} #{entity&.canonical_id}")
                entity.reload
              },
              &block
            )
          else
            block.call
          end
        end
      end
    end
  end
end
